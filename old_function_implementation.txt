#ifndef CALLABLE_H
#define CALLABLE_H

#include "core/types.h"
#include "ast/ast_callable.h"
#include "core/functions/param_node.h"
#include "core/errors.h" 

class Scope;
class Node;
class ParamList;
class Method;

// Callable is the abstract base for all callables (functions and methods).
class Callable : public std::enable_shared_from_this<Callable> {
public:
    String name;
    mutable ParamList parameters;
    CallableType callType;
    CallableType subType;
    bool requiresReturn = true;

    Callable() {}
    Callable(Callable& callable); 
    Callable(Method& method);
    Callable(Function& function);
    Callable(String name, ParamList params, CallableType callType);
    Callable(String name, ParamList params, CallableType callType, bool requiresReturn);
    virtual ~Callable() = default;
    
    // Execute the callable with the provided arguments and scope.
    virtual Node execute(Vector<Node> args, SharedPtr<Scope> scope, [[maybe_unused]] SharedPtr<ClassInstanceNode> instanceNode = nullptr) const = 0;
    
    // Set and get the captured scope.
    virtual void setCapturedScope(SharedPtr<Scope> scope) = 0;
    virtual SharedPtr<Scope> getCapturedScope() const = 0;
    
    // Produce a FunctionSignature for registration.
    virtual SharedPtr<class CallableSignature> toCallableSignature() = 0;
    virtual String toString() const = 0; 

    virtual void setScope(SharedPtr<Scope> newScope) const = 0;
    
    String getName() const;
    String& getQualifiedName();

    CallableType getCallableType() const;
    CallableType getSubType() const;
    void setSubType(CallableType subClassification);
    void setCallableType(CallableType primaryClassification);
};


class CallableNode : public Node {
protected:
    SharedPtr<Scope> internalScope; // Optional — used for chained resolution

public:
    explicit CallableNode(SharedPtr<Callable> callable, String callableType = "Callable");
    explicit CallableNode(SharedPtr<CallableNode> callableNode); // for returning non shared callable node 

    virtual SharedPtr<Callable> getCallable() const;

    void setInternalScope(SharedPtr<Scope> scope);
    SharedPtr<Scope> getInternalScope() const;

    virtual String toString() const;
};




#endif // CALLABLE_H 



#include "core/functions/callable.h"
#include "core/classes/method.h"


Callable::Callable(Method& method){
    callType = method.callType;
    requiresReturn = method.requiresReturn;
    parameters = method.parameters;
    name = method.name;
    if (callableTypeAsString(callType) == "Unknown"){
        throw MerkError("Failed to instantiate callType at Callable::Callable copy from method instantiation");
    }
}

Callable::Callable(Function& function){
    callType = function.callType;
    requiresReturn = function.requiresReturn;
    parameters = function.parameters;
    name = function.name;
    if (callableTypeAsString(callType) == "Unknown"){
        throw MerkError("Failed to instantiate callType at Callable::Callable copy from function instantiation");
    }
}

Callable::Callable(Callable& callable)
    : std::enable_shared_from_this<Callable>(), // explicitly initialize the base
      name(callable.name),
      parameters(callable.parameters),
      callType(callable.callType),
      requiresReturn(callable.requiresReturn)
{
    if (callableTypeAsString(callType) == "Unknown"){
        throw MerkError("Failed to instantiate callType at Callable::Callable copy from callable instantiation");
    }
}


String& Callable::getQualifiedName() {
    String& newName = name;
    return newName;
}

Callable::Callable(String name, ParamList params, CallableType callType)
    : name(std::move(name)), parameters(std::move(params)), callType(callType) {
        if (callableTypeAsString(callType) == "Unknown"){
            throw MerkError("Failed to instantiate callType at Callable::Callable instantiation");
        }
    }

Callable::Callable(String name, ParamList params, CallableType callType, bool requiresReturn)
    : name(std::move(name)), parameters(std::move(params)), callType(callType), requiresReturn(requiresReturn) {
        if (callableTypeAsString(callType) == "Unknown"){
            throw MerkError("Failed to instantiate callType at Callable::Callable with requiresReturn instantiation");
        }
    }


String Callable::getName() const { return name; }

void Callable::setCallableType(CallableType primaryClassification) {callType = primaryClassification;} 
CallableType Callable::getCallableType() const { return callType; }


void Callable::setSubType(CallableType subClassification) {subType = subClassification;} 
CallableType Callable::getSubType() const {return subType;}



        
CallableNode::CallableNode(SharedPtr<Callable> callable, String callableType ) {
    data.type = NodeValueType::Callable;
    data.value = callable; // Stored as SharedPtr<Callable>
    nodeType = callableType + "(" + callable->name + ")";
    isCallable = true;
    name = callable->name;
}

CallableNode::CallableNode(SharedPtr<CallableNode> callableNode) {
    data.type = callableNode->data.type;
    data.value = callableNode->getValue(); // Stored as SharedPtr<Callable>
    nodeType = callableNode->nodeType + "(" + callableNode->name + ")";
    isCallable = true;
    name = callableNode->name;
}

SharedPtr<Callable> CallableNode::getCallable() const {
    return std::get<SharedPtr<Callable>>(data.value);
}

void CallableNode::setInternalScope(SharedPtr<Scope> scope) { internalScope = scope; }
SharedPtr<Scope> CallableNode::getInternalScope() const { return internalScope; }

String CallableNode::toString() const {
    return "<" + nodeType + ": " + getCallable()->toString() + ">";
}









// core/functions/function_node.h
#ifndef FUNCTION_NODE_H
#define FUNCTION_NODE_H

#include <functional>
#include <memory> 

#include "core/types.h"
#include "core/node.h"
#include "core/functions/param_node.h"    // For ParamList
#include "ast/ast_control.h"              // For CodeBlock
#include "core/functions/callable.h"      // New base callable class
#include "ast/ast_callable.h"



class Scope;

class FunctionBody : public CallableBody {
    public:
        friend class MethodBody;
        FunctionBody(SharedPtr<Scope> scope);
    
        // Steal Constructor
        FunctionBody(UniquePtr<CodeBlock>&& block);
    
        ~FunctionBody();
    
        virtual Node evaluate(SharedPtr<Scope> scope, [[maybe_unused]] SharedPtr<ClassInstanceNode> instanceNode = nullptr) const override;
        virtual UniquePtr<BaseAST> clone() const override;
        virtual AstType getAstType() const override { return AstType::FunctionBlock;}    
        void printAST(std::ostream& os, int indent = 0) const override;
        Vector<UniquePtr<BaseAST>>& getChildren(){return children;};
    };




// Function inherits from Callable.
class Function : public Callable {
protected:
    CallableType subType = CallableType::DEF;
public:
    Function(String name, ParamList params, CallableType functionType);
    virtual ~Function() = default;

    // Execute must be implemented by derived classes.
    virtual Node execute(const Vector<Node> args, SharedPtr<Scope> scope, [[maybe_unused]] SharedPtr<ClassInstanceNode> instanceNode = nullptr) const = 0;

    // Return a FunctionSignature representing this callable.
    virtual SharedPtr<CallableSignature> toCallableSignature() = 0;

    virtual FunctionBody* getBody() const { return nullptr; }

    virtual String toString() const override = 0;

    virtual void setCapturedScope(SharedPtr<Scope> scope) = 0;
    virtual SharedPtr<Scope> getCapturedScope() const = 0;
    virtual void setScope(SharedPtr<Scope> newScope) const override = 0;


};
    
class UserFunction : public Function {
private:
    SharedPtr<Scope> capturedScope;  // Store the captured scope to prevent automatic destruction (a shared_ptr)

public:
    UniquePtr<FunctionBody> body;   // The function’s code block


public:
    UserFunction(String name, UniquePtr<FunctionBody> body, ParamList parameters, CallableType funcType);

    Node execute(Vector<Node> args, SharedPtr<Scope> scope, [[maybe_unused]] SharedPtr<ClassInstanceNode> instanceNode = nullptr) const override;

    void setCapturedScope(SharedPtr<Scope> scope);

    SharedPtr<Scope> getCapturedScope() const;

    SharedPtr<CallableSignature> toCallableSignature() override;
    
    FunctionBody* getBody() const override;
    // UniquePtr<CallableBody> getBody() const override {return body;}

    String toString() const override {return "<Function: " + getName() + ">";}
    void setScope(SharedPtr<Scope> newScope) const override;

};


class FunctionNode : public CallableNode {
public:
    FunctionNode(SharedPtr<Function> function);

    FunctionNode(SharedPtr<Callable> function);
    SharedPtr<Callable> getCallable() const override;
};


#endif // FUNCTION_NODE_H






#include "core/types.h"
#include "core/node.h"
#include "utilities/debugger.h"

#include "core/scope.h" 
#include "ast/ast.h"
#include "ast/exceptions.h"
#include "ast/ast_control.h"

#include "core/functions/param_node.h"
#include "ast/ast_function.h"

#include "ast/ast_callable.h"


FunctionBody::FunctionBody(SharedPtr<Scope> scope) : CallableBody(scope) {
    DEBUG_FLOW(FlowLevel::VERY_LOW);

    DEBUG_LOG(LogLevel::DEBUG, "Creating FunctionBody with scope level: ", scope->getScopeLevel());
    if (!scope){
        throw MerkError("FunctionBody Must Have A Valid Scope: ");
    }

    DEBUG_FLOW_EXIT();
}

Function::Function(String name, ParamList params, CallableType funcType)
    : Callable(name, params, CallableType::FUNCTION)
{
    DEBUG_FLOW(FlowLevel::VERY_LOW);
    

    DEBUG_LOG(LogLevel::TRACE, "FuncType: ", callableTypeAsString(funcType));
    DEBUG_FLOW_EXIT();
}

UserFunction::UserFunction(String name, UniquePtr<FunctionBody> body, ParamList parameters, CallableType funcType)
    : Function(name, parameters, CallableType::FUNCTION), body(std::move(body)) {
        DEBUG_FLOW(FlowLevel::LOW);
        
        setSubType(funcType);
            
        setCallableType(CallableType::FUNCTION);
        DEBUG_FLOW_EXIT();
}

FunctionBody* UserFunction::getBody() const {return body.get();}

void UserFunction::setCapturedScope(SharedPtr<Scope> scope) {
    if (!scope) {
        throw MerkError("Cannot set a null scope in UserFunction.");
    }
    capturedScope = scope;
   
    body->setScope(capturedScope);
}

SharedPtr<Scope> UserFunction::getCapturedScope() const {
    return capturedScope;
}

Node UserFunction::execute(Vector<Node> args, SharedPtr<Scope> scope, [[maybe_unused]] SharedPtr<ClassInstanceNode> instanceNode) const {
    (void)args;
    DEBUG_FLOW();
    if (!scope){
        throw MerkError("Starting Scope Null in: UserFunction::execute");
    }

    Node value;
    try {
        value = body->evaluate(scope);
    } catch (const ReturnException& e) {
        DEBUG_LOG(LogLevel::DEBUG, highlight("Caught ReturnException In Function Execution. Returning value:", Colors::red), e.getValue());
        DEBUG_FLOW_EXIT();
        return e.getValue();  // Extract and return function's result
    }

    DEBUG_FLOW_EXIT();
    throw MerkError("Function did not return a value.");
}

FunctionBody::~FunctionBody(){DEBUG_LOG(LogLevel::TRACE, highlight("Destroying FunctionBody", Colors::orange)); getScope().reset();} 

SharedPtr<CallableSignature> UserFunction::toCallableSignature() {
    DEBUG_FLOW(FlowLevel::LOW);

    SharedPtr<CallableSignature> funcSig = makeShared<CallableSignature>(
        shared_from_this(), getCallableType()
    );

    funcSig->setSubType(getSubType());

    if (funcSig->getCallableType() == CallableType::DEF) {
        throw MerkError("Primary Callable Type is: " + callableTypeAsString(funcSig->getCallableType()));
    }
 
    DEBUG_FLOW_EXIT();
    return funcSig;
}

void UserFunction::setScope(SharedPtr<Scope> newScope) const {
    newScope->owner = generateScopeOwner("UserFunction", name);
    getBody()->setScope(newScope);
}


FunctionNode::FunctionNode(SharedPtr<Function> function) : CallableNode(function, "Function") {data.type = NodeValueType::Function;}

FunctionNode::FunctionNode(SharedPtr<Callable> function) : CallableNode(function, "Function") {data.type = NodeValueType::Function;}
SharedPtr<Callable> FunctionNode::getCallable() const {return std::get<SharedPtr<Function>>(data.value);}
